# エージェントループ制御ガイド

## 概要

このドキュメントでは、Strands Agentのhookシステムを使用したReActループの最大回数制御について説明します。

## 実装内容

### 1. ループ制御フック（LoopControlHook）

`handlers/loop_control_hook.py`に実装されたフックで、以下の機能を提供します：

- **BeforeInvocationEvent**: エージェント呼び出し開始時にループカウントを初期化
- **BeforeModelCallEvent**: モデル呼び出し前にログを出力
- **AfterModelCallEvent**: モデル呼び出し後にループカウントをインクリメントし、最大回数をチェック
- **AfterInvocationEvent**: エージェント呼び出し終了時に合計ループ回数をログ出力

### 2. エージェントへの適用

#### オーケストレーターエージェント（reception_agent）

```python
loop_control_hook = LoopControlHook(
    max_iterations=15,  # オーケストレーターは専門エージェントとのやり取りがあるため多めに設定
    agent_name="申請受付窓口エージェント"
)

agent = Agent(
    ...
    hooks=[loop_control_hook]
)
```

#### 専門エージェント（travel_agent、receipt_expense_agent）

```python
loop_control_hook = LoopControlHook(
    max_iterations=10,  # 専門エージェントは特定タスクに集中するため標準的な回数
    agent_name="交通費精算申請エージェント"  # または "経費精算申請エージェント"
)

agent = Agent(
    ...
    hooks=[approval_hook, loop_control_hook]
)
```

### 3. エラーハンドリング

#### 専門エージェント（Agent as Tools）

専門エージェントでループ制限に達した場合、`RuntimeError`をキャッチして、ユーザーフレンドリーなメッセージを返します：

```python
except RuntimeError as e:
    if "エージェントループの制限" in str(e):
        return (
            "申し訳ございません。処理が複雑すぎて完了できませんでした。\n\n"
            "以下のいずれかをお試しください：\n"
            "1. 経路を1つずつ申請してください\n"
            "2. より具体的な情報を提供してください\n"
            "3. 不要な情報を削除してください\n\n"
            "もう一度、シンプルな内容でお試しください。"
        )
```

#### オーケストレーターエージェント

オーケストレーターでループ制限に達した場合、`RuntimeError`をキャッチして、ユーザーに分かりやすいメッセージを表示します：

```python
except RuntimeError as e:
    if "エージェントループの制限" in str(e):
        print("\n" + "="*60)
        print("【エージェントループ制限エラー】")
        print("="*60)
        print(f"\n{str(e)}")
        print("\n" + "="*60)
        print("もう一度、シンプルな内容でお試しください。")
```

## エージェントフローの表示

ループ制御フックは、エージェントの実行フローをログに出力します：

```
[申請受付窓口エージェント] エージェント呼び出し開始
[申請受付窓口エージェント] 最大ループ回数: 15
[申請受付窓口エージェント] モデル呼び出し #1
[申請受付窓口エージェント] モデル呼び出し完了 (1/15)
[交通費精算申請エージェント] エージェント呼び出し開始
[交通費精算申請エージェント] 最大ループ回数: 10
[交通費精算申請エージェント] モデル呼び出し #1
[交通費精算申請エージェント] モデル呼び出し完了 (1/10)
...
[交通費精算申請エージェント] エージェント呼び出し終了（合計ループ回数: 5）
[申請受付窓口エージェント] モデル呼び出し #2
[申請受付窓口エージェント] モデル呼び出し完了 (2/15)
[申請受付窓口エージェント] エージェント呼び出し終了（合計ループ回数: 2）
```

## Agent as Toolsのネスト構造

Agent as Toolsの実装では、以下のようなネスト構造になります：

1. **オーケストレーター（親）**: BeforeInvocationEvent → モデル呼び出し
2. **専門エージェント（子）**: BeforeInvocationEvent → モデル呼び出し → ... → AfterInvocationEvent
3. **オーケストレーター（親）**: モデル呼び出し → ... → AfterInvocationEvent

各エージェントは独立したループカウントを持ち、それぞれの最大回数で制御されます。

## 最大回数の設定指針

- **オーケストレーターエージェント**: 15回
  - 複数の専門エージェントとのやり取りがあるため、多めに設定
  - ユーザーとの対話、専門エージェントの呼び出し、結果の確認などが含まれる

- **専門エージェント**: 10回
  - 特定のタスクに集中するため、標準的な回数
  - 情報収集、ツール呼び出し、結果の確認などが含まれる

## トラブルシューティング

### ループ制限に頻繁に達する場合

1. **タスクの分割**: 複数の申請を一度に行う場合は、1つずつ申請する
2. **具体的な指示**: より詳細な情報を提供する
3. **不要な情報の削除**: 申請に関係のない質問や情報は別途行う
4. **最大回数の調整**: 必要に応じて`max_iterations`を増やす（ただし、無限ループのリスクに注意）

### ログの確認

ログファイル（`logs/error.log`）を確認して、どのエージェントでループ制限に達したかを確認できます。

## まとめ

- ループ制御フックは、ReActループの最大回数を制御し、無限ループを防ぎます
- オーケストレーターと専門エージェントの両方に適用されます
- エラーが発生した場合、ユーザーフレンドリーなメッセージを表示します
- エージェントのフローをログに出力し、デバッグを容易にします
